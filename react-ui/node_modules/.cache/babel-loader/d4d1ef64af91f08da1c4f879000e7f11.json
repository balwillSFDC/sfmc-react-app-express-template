{"ast":null,"code":"/*\r\n * Copyright (c) 2018, salesforce.com, inc.\r\n * All rights reserved.\r\n * Licensed under the BSD 3-Clause license.\r\n * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause\r\n */\n'use strict';\n\nconst request = require('request');\n\nconst merge = require('lodash.merge');\n\nconst version = require('../package.json').version;\n\nmodule.exports = class FuelAuth {\n  constructor(options) {\n    var isOauth2Flow = options && options.authOptions ? options.authOptions.authVersion === 2 : false;\n\n    if (options) {\n      if (!options.clientId) {\n        throw new Error('clientId or clientSecret is missing or invalid');\n      }\n\n      if (typeof options.clientId !== 'string') {\n        throw new Error('clientId or clientSecret must be strings');\n      }\n\n      if (isOauth2Flow) {\n        if (options.authOptions.applicationType !== 'public') {\n          if (!options.clientSecret) {\n            throw new Error('clientId or clientSecret is missing or invalid');\n          }\n\n          if (typeof options.clientSecret !== 'string') {\n            throw new Error('clientId or clientSecret must be strings');\n          }\n        }\n\n        if (!options.authUrl) {\n          throw new Error('Auth URL is mandatory for OAuth2 Authentication');\n        }\n\n        if (options.authOptions.applicationType === 'public' || options.authOptions.applicationType === 'web') {\n          if (!options.authOptions.redirectURI || !options.authOptions.authorizationCode) {\n            throw new Error('RedirectURI and Authorization Code are required for Public/Web App OAuth2 Authentication');\n          }\n        }\n      } else {\n        if (!options.clientSecret) {\n          throw new Error('clientId or clientSecret is missing or invalid');\n        }\n\n        if (typeof options.clientSecret !== 'string') {\n          throw new Error('clientId or clientSecret must be strings');\n        }\n      }\n    } else {\n      throw new Error('options are required. see readme.');\n    } // set required values\n\n\n    this.accessToken = options.accessToken;\n    this.authUrl = options.authUrl || 'https://auth.exacttargetapis.com/v1/requestToken';\n    this.clientId = options.clientId;\n    this.clientSecret = options.clientSecret;\n    this.expiration = null;\n    this.refreshToken = options.refreshToken;\n    this.version = version;\n    this.globalReqOptions = options.globalReqOptions || {};\n\n    if (options.authOptions) {\n      this.accountId = options.authOptions.accountId;\n      this.authVersion = options.authOptions.authVersion;\n      this.scope = options.authOptions.scope;\n      this.applicationType = options.authOptions.applicationType;\n      this.redirectURI = options.authOptions.redirectURI;\n      this.authorizationCode = options.authOptions.authorizationCode;\n      this.soapUrl = null;\n      this.restUrl = null;\n    }\n  }\n\n  getAccessToken(options, callback) {\n    let done = callback;\n    options = options || {};\n\n    if (typeof options === 'function') {\n      done = options;\n      options = {};\n    }\n\n    if (done !== undefined && typeof done !== 'function') {\n      throw new TypeError('argument callback must be a function');\n    }\n\n    const getNewToken = this.isExpired() || Boolean(options.force);\n    delete options.force;\n\n    if (done) {\n      return this._processRequest(getNewToken, options, done);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._processRequest(getNewToken, options, function (err, data) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(data);\n      });\n    });\n  }\n\n  isExpired() {\n    let expired = false; // if current atomic time is equal or after exp, or we don't have a token, return true\n\n    if (this.expiration && this.expiration <= process.hrtime()[0] || !this.accessToken) {\n      expired = true;\n    }\n\n    return expired;\n  }\n\n  invalidateToken(accessToken) {\n    if (accessToken === undefined) {\n      this.accessToken = undefined;\n    } else if (typeof accessToken !== 'string') {\n      throw new TypeError('accessToken must be string type');\n    } else if (this.accessToken === accessToken) {\n      this.accessToken = undefined;\n    }\n  }\n\n  _processRequest(getNewToken, options, callback) {\n    if (getNewToken) {\n      this._requestToken(options).then(body => callback(null, body)).catch(err => callback(err, null));\n    } else {\n      let response = {\n        accessToken: this.accessToken,\n        expiresIn: this.expiration - process.hrtime()[0]\n      };\n\n      if (this.authVersion === 2) {\n        response.rest_instance_url = this.restUrl;\n        response.soap_instance_url = this.soapUrl;\n      }\n\n      callback(null, response);\n    }\n  }\n\n  createPayloadForOauth2() {\n    const payload = {};\n    payload.client_id = this.clientId;\n\n    if (this.applicationType !== 'public') {\n      payload.client_secret = this.clientSecret;\n    }\n\n    if (this.refreshToken) {\n      payload.grant_type = 'refresh_token';\n      payload.refresh_token = this.refreshToken;\n    } else if (this.applicationType === 'public' || this.applicationType === 'web') {\n      payload.grant_type = 'authorization_code';\n      payload.code = this.authorizationCode;\n      payload.redirect_uri = this.redirectURI;\n    } else {\n      payload.grant_type = 'client_credentials';\n    }\n\n    if (this.accountId) {\n      payload.account_id = this.accountId;\n    }\n\n    if (this.scope) {\n      payload.scope = this.scope;\n    }\n\n    return payload;\n  }\n\n  _requestToken(requestOptions) {\n    var payload = {};\n\n    if (this.authVersion === 2) {\n      payload = this.createPayloadForOauth2();\n    } else {\n      payload.clientId = this.clientId;\n      payload.clientSecret = this.clientSecret;\n    } // set auth options for request\n\n\n    const baseOptions = {\n      url: this.authUrl,\n      method: 'POST',\n      json: payload\n    };\n    const options = merge({}, this.globalReqOptions, baseOptions, requestOptions);\n\n    if (this.authVersion === undefined || this.authVersion !== 2) {\n      if (this.refreshToken) {\n        // adding refresh token to json if it's there\n        options.json.refreshToken = this.refreshToken;\n      } else if (this.scope) {\n        // adding scope to json if it's there\n        // it's not valid to use both scope and a refresh token\n        options.json.scope = this.scope;\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      request(options, (err, res, body) => {\n        if (err) {\n          return reject(err);\n        }\n\n        if (!body) {\n          let localError = new Error('No response body');\n          localError.res = res;\n          reject(localError);\n          return;\n        } // setting variables on object created to be used later\n\n\n        if (body.refreshToken) {\n          this.refreshToken = body.refreshToken;\n        }\n\n        if (this.authVersion === 2) {\n          this.accessToken = body.access_token || null;\n          body.accessToken = this.accessToken;\n          this.soapUrl = body.soap_instance_url;\n          this.restUrl = body.rest_instance_url;\n          this.expiration = body.expires_in ? process.hrtime()[0] + body.expires_in : null;\n\n          if (body.refresh_token) {\n            this.refreshToken = body.refresh_token;\n          }\n        } else {\n          this.accessToken = body.accessToken || null;\n          this.expiration = body.expiresIn ? process.hrtime()[0] + body.expiresIn : null;\n        }\n\n        resolve(body);\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["C:/Users/balwi/Documents/Coding/react-sfmc-api-poc/node_modules/fuel-auth/lib/fuel-auth.js"],"names":["request","require","merge","version","module","exports","FuelAuth","constructor","options","isOauth2Flow","authOptions","authVersion","clientId","Error","applicationType","clientSecret","authUrl","redirectURI","authorizationCode","accessToken","expiration","refreshToken","globalReqOptions","accountId","scope","soapUrl","restUrl","getAccessToken","callback","done","undefined","TypeError","getNewToken","isExpired","Boolean","force","_processRequest","Promise","resolve","reject","err","data","expired","process","hrtime","invalidateToken","_requestToken","then","body","catch","response","expiresIn","rest_instance_url","soap_instance_url","createPayloadForOauth2","payload","client_id","client_secret","grant_type","refresh_token","code","redirect_uri","account_id","requestOptions","baseOptions","url","method","json","res","localError","access_token","expires_in"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2018, salesforce.com, inc.\r\n * All rights reserved.\r\n * Licensed under the BSD 3-Clause license.\r\n * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause\r\n */\r\n'use strict';\r\n\r\nconst request = require('request');\r\nconst merge = require('lodash.merge');\r\nconst version = require('../package.json').version;\r\n\r\nmodule.exports = class FuelAuth {\r\n\tconstructor(options) {\t\r\n\t\tvar isOauth2Flow = options && options.authOptions ? options.authOptions.authVersion === 2 : false;\r\n\t\tif (options) {\r\n\t\t\tif (!options.clientId) {\r\n\t\t\t\tthrow new Error('clientId or clientSecret is missing or invalid');\r\n\t\t\t}\r\n\t\t\tif (typeof options.clientId !== 'string') {\r\n\t\t\t\tthrow new Error('clientId or clientSecret must be strings');\r\n\t\t\t}\r\n\t\t\tif(isOauth2Flow) {\r\n\t\t\t\tif(options.authOptions.applicationType !== 'public'){\r\n\t\t\t\t\tif (!options.clientSecret) {\r\n\t\t\t\t\t\tthrow new Error('clientId or clientSecret is missing or invalid');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof options.clientSecret !== 'string') {\r\n\t\t\t\t\t\tthrow new Error('clientId or clientSecret must be strings');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!options.authUrl) {\r\n\t\t\t\t\tthrow new Error('Auth URL is mandatory for OAuth2 Authentication');\r\n\t\t\t\t}\r\n\t\t\t\tif(options.authOptions.applicationType === 'public' || options.authOptions.applicationType === 'web'){\r\n\t\t\t\t\tif(!options.authOptions.redirectURI || !options.authOptions.authorizationCode){\r\n\t\t\t\t\t\tthrow new Error('RedirectURI and Authorization Code are required for Public/Web App OAuth2 Authentication');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!options.clientSecret) {\r\n\t\t\t\t\tthrow new Error('clientId or clientSecret is missing or invalid');\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof options.clientSecret !== 'string') {\r\n\t\t\t\t\tthrow new Error('clientId or clientSecret must be strings');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthrow new Error('options are required. see readme.');\r\n\t\t}\r\n\r\n\t\t// set required values\r\n\t\tthis.accessToken = options.accessToken;\r\n\t\tthis.authUrl = options.authUrl || 'https://auth.exacttargetapis.com/v1/requestToken';\r\n\t\tthis.clientId = options.clientId;\r\n\t\tthis.clientSecret = options.clientSecret;\r\n\t\tthis.expiration = null;\r\n\t\tthis.refreshToken = options.refreshToken;\r\n\t\tthis.version = version;\r\n\t\tthis.globalReqOptions = options.globalReqOptions || {};\r\n\r\n\t\tif(options.authOptions){\r\n\t\t\tthis.accountId = options.authOptions.accountId;\r\n\t\t\tthis.authVersion = options.authOptions.authVersion;\r\n\t\t\tthis.scope = options.authOptions.scope;\r\n\t\t\tthis.applicationType = options.authOptions.applicationType;\r\n\t\t\tthis.redirectURI = options.authOptions.redirectURI;\r\n\t\t\tthis.authorizationCode = options.authOptions.authorizationCode;\r\n\t\t\tthis.soapUrl = null;\r\n\t\t\tthis.restUrl = null;\r\n\t\t}\r\n\t}\r\n\tgetAccessToken(options, callback) {\r\n\t\tlet done = callback;\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\tif (typeof options === 'function') {\r\n\t\t\tdone = options;\r\n\t\t\toptions = {};\r\n\t\t}\r\n\r\n\t\tif (done !== undefined && typeof done !== 'function') {\r\n\t\t\tthrow new TypeError('argument callback must be a function');\r\n\t\t}\r\n\r\n\t\tconst getNewToken = this.isExpired() || Boolean(options.force);\r\n\r\n\t\tdelete options.force;\r\n\r\n\t\tif (done) {\r\n\t\t\treturn this._processRequest(getNewToken, options, done);\r\n\t\t}\r\n\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tthis._processRequest(getNewToken, options, function(err, data) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\treturn reject(err);\r\n\t\t\t\t}\r\n\t\t\t\tresolve(data);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tisExpired() {\r\n\t\tlet expired = false;\r\n\r\n\t\t// if current atomic time is equal or after exp, or we don't have a token, return true\r\n\t\tif ((this.expiration && this.expiration <= process.hrtime()[0]) || !this.accessToken) {\r\n\t\t\texpired = true;\r\n\t\t}\r\n\r\n\t\treturn expired;\r\n\t}\r\n\tinvalidateToken(accessToken) {\r\n\t\tif (accessToken === undefined) {\r\n\t\t\tthis.accessToken = undefined;\r\n\t\t} else if (typeof accessToken !== 'string') {\r\n\t\t\tthrow new TypeError('accessToken must be string type');\r\n\t\t} else if (this.accessToken === accessToken) {\r\n\t\t\tthis.accessToken = undefined;\r\n\t\t}\r\n\t}\r\n\t_processRequest(getNewToken, options, callback) {\r\n\t\tif (getNewToken) {\r\n\t\t\tthis._requestToken(options)\r\n\t\t\t\t.then(body => callback(null, body))\r\n\t\t\t\t.catch(err => callback(err, null));\r\n\t\t} else {\r\n\t\t\tlet response = {\r\n\t\t\t\taccessToken: this.accessToken,\r\n\t\t\t\texpiresIn: this.expiration - process.hrtime()[0]\r\n\t\t\t};\r\n\t\t\tif(this.authVersion === 2) {\r\n\t\t\t\tresponse.rest_instance_url = this.restUrl;\r\n\t\t\t\tresponse.soap_instance_url = this.soapUrl;\r\n\t\t\t}\r\n\t\t\tcallback(null, response);\r\n\t\t}\r\n\t}\r\n\tcreatePayloadForOauth2(){\r\n\t\tconst payload = {};\r\n\t\tpayload.client_id = this.clientId;\r\n\t\tif(this.applicationType !== 'public'){\r\n\t\t\tpayload.client_secret = this.clientSecret;\r\n\t\t}\r\n\t\t\r\n\t\tif(this.refreshToken){\r\n\t\t\tpayload.grant_type = 'refresh_token';\r\n\t\t\tpayload.refresh_token = this.refreshToken;\r\n\t\t}\r\n\t\telse if(this.applicationType === 'public' || this.applicationType === 'web'){\r\n\t\t\tpayload.grant_type = 'authorization_code';\r\n\t\t\tpayload.code = this.authorizationCode;\r\n\t\t\tpayload.redirect_uri = this.redirectURI;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpayload.grant_type = 'client_credentials';\r\n\t\t}\r\n\t\t\t\r\n\t\tif(this.accountId){\r\n\t\t\tpayload.account_id = this.accountId;\r\n\t\t}\r\n\t\tif(this.scope){\r\n\t\t\tpayload.scope = this.scope;\r\n\t\t}\r\n\t\treturn payload;\t\r\n\t}\r\n\t_requestToken(requestOptions) {\r\n\t\tvar payload = {};\r\n\t\tif(this.authVersion === 2){\r\n\t\t\tpayload = this.createPayloadForOauth2();\r\n\t\t} else {\r\n\t\t\tpayload.clientId = this.clientId;\r\n\t\t\tpayload.clientSecret = this.clientSecret;\r\n\t\t}\r\n\t\t// set auth options for request\r\n\t\tconst baseOptions = {\r\n\t\t\turl: this.authUrl,\r\n\t\t\tmethod: 'POST',\r\n\t\t\tjson: payload\r\n\t\t};\r\n\r\n\t\tconst options = merge({}, this.globalReqOptions, baseOptions, requestOptions);\r\n\t\t\r\n\t\tif(this.authVersion === undefined || this.authVersion !== 2){\r\n\t\t\tif (this.refreshToken) {\r\n\t\t\t\t// adding refresh token to json if it's there\r\n\t\t\t\toptions.json.refreshToken = this.refreshToken;\r\n\t\t\t} else if (this.scope) {\r\n\t\t\t\t// adding scope to json if it's there\r\n\t\t\t\t// it's not valid to use both scope and a refresh token\r\n\t\t\t\toptions.json.scope = this.scope;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\trequest(options, (err, res, body) => {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\treturn reject(err);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!body) {\r\n\t\t\t\t\tlet localError = new Error('No response body');\r\n\t\t\t\t\tlocalError.res = res;\r\n\t\t\t\t\treject(localError);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// setting variables on object created to be used later\r\n\t\t\t\tif (body.refreshToken) {\r\n\t\t\t\t\tthis.refreshToken = body.refreshToken;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(this.authVersion === 2){\r\n\t\t\t\t\tthis.accessToken = body.access_token || null;\r\n\t\t\t\t\tbody.accessToken = this.accessToken;\r\n\t\t\t\t\tthis.soapUrl = body.soap_instance_url;\r\n\t\t\t\t\tthis.restUrl = body.rest_instance_url;\r\n\t\t\t\t\tthis.expiration = body.expires_in ? process.hrtime()[0] + body.expires_in : null;\r\n\t\t\t\t\tif (body.refresh_token) {\r\n\t\t\t\t\t\tthis.refreshToken = body.refresh_token;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.accessToken = body.accessToken || null;\r\n\t\t\t\t\tthis.expiration = body.expiresIn ? process.hrtime()[0] + body.expiresIn : null;\t\r\n\t\t\t\t}\r\n\t\t\t\tresolve(body);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}